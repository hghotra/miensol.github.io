{"componentChunkName":"component---src-templates-post-template-tsx","path":"/an-https-system-proxy-with-node/","result":{"data":{"markdownRemark":{"id":"696b9e9f-2f34-5428-83ac-6b218d874162","html":"<p>Creating a simple http proxy in node.js is super easy thanks to an excellent module – <a href=\"https://github.com/nodejitsu/node-http-proxy\" target=\"_blank\">http-proxy</a>.\n  With only the following code you’ll have a proxy that can be used as system or\n  browser level proxy:</p>\n```\nvar httpProxy = require('http-proxy');\nvar proxyServer = httpProxy.createServer(function (req,res,proxy) {\n  var hostNameHeader = req.headers.host,\n  hostAndPort = hostNameHeader.split(':'),\n  host = hostAndPort[0],\n  port = parseInt(hostAndPort[1]) || 80;\n  proxy.proxyRequest(req,res, {\n    host: host,\n    port: port\n  });\n});\nproxyServer.listen(8888);\n```\n<h2>Adding support for HTTPS</h2>\n<p>The first thing we will need is a certificate that will be used by <a href=\"http://en.wikipedia.org/wiki/Transport_Layer_Security\" target=\"_blank\">TLS</a> implementation for encryption. A server has access to certificate private and public key thus it is\n  able to get a clear text from a message encrypted with public key. It’s a common knowledge that asymmetric encryption is more expensive in terms of CPU cycles than its symmetric counterpart. That’s way when using HTTPS connection asymmetric encryption\n  is only used during initial handshake to exchange a session key in a secure manner between client and server. This session key is then used by both client and server for traffic encryption using symmetric algorithm.</p>\n<p>Naturally to get or rather to buy a proper certificate one would have to be verified by a valid certification authority. Fortunately for the sake of a demo we can generate a self signed certificate. That’s really easy, a nice description is available\n  on <a href=\"https://devcenter.heroku.com/articles/ssl-certificate-self\" target=\"_blank\">heroku help pages</a>:</p>\n```\nopenssl genrsa -des3 -passout pass:x -out proxy-mirror.pass.key 2048\necho \"Generated proxy-mirror.pass.key\"\n<p>openssl rsa -passin pass:x -in proxy-mirror.pass.key -out proxy-mirror.key\nrm proxy-mirror.pass.key\necho “Generated proxy-mirror.key”</p>\n<p>openssl req -new -batch -key proxy-mirror.key -out proxy-mirror.csr -subj /CN=proxy-mirror/emailAddress=piotr.mionskowski@gmail.com/OU=proxy-mirror/C=PL/O=proxy-mirror\necho “Generated proxy-mirror.csr”</p>\n<p>openssl x509 -req -days 365 -in proxy-mirror.csr -signkey proxy-mirror.key -out proxy-mirror.crt\necho “Generated proxy-mirror.crt”</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;h3&gt;http-proxy support for https&lt;/h3&gt;\n&lt;p&gt;http-proxy module supports various https configuration for example passing traffic from https to http and vice versa. Unfortunately I couldn’t find a way to get it working without preconfiguring target host and port – which was a problem while I was implementing\n  &lt;a\n  href=&quot;https://github.com/miensol/proxy-mirror&quot; target=&quot;_blank&quot;&gt;proxy-mirror&lt;/a&gt;. Here is what &lt;em&gt;curl&lt;/em&gt;will print out when trying to use such proxy:&lt;/p&gt;</code></pre></div>\n<p>curl -vk —proxy <a href=\"https://localhost:8888/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://localhost:8888/</a> <a href=\"https://pl-pl.facebook.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://pl-pl.facebook.com/</a></p>\n<ul>\n<li>timeout on name lookup is not supported</li>\n<li>About to connect() to proxy localhost port 8888 (#0)</li>\n<li>Trying 127.0.0.1…</li>\n<li>connected</li>\n<li>Connected to localhost (127.0.0.1) port 8888 (#0)</li>\n<li>\n<p>Establish HTTP proxy tunnel to pl-pl.facebook.com:443\n> CONNECT pl-pl.facebook.com:443 HTTP/1.1\n> Host: pl-pl.facebook.com:443\n> User-Agent: curl/7.26.0\n> Proxy-Connection: Keep-Alive\n></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n</li>\n</ul>\n<p>I suspect the problem is inherently related to the way http-proxy uses nodejs core http(s) modules – I might be wrong here though. The workaround I’ve used in <a href=\"https://github.com/miensol/proxy-mirror\" target=\"_blank\">proxy-mirror</a> was to listen\n  to <em><a href=\"http://nodejs.org/api/http.html#http_event_connect\" target=\"_blank\">CONNECT</a>    </em>event on http server, establish socket connection to a fake https server listening on different port. When the https connection is established the\n  fake https server handler proxies requests further. The advantage of this approach is that we can use the same proxy address for both http and https. Here is the code:</p>\n```\nvar httpProxy = require('http-proxy'),\n  fs = require('fs'),\n  https = require('https'),\n  net = require('net'),\n  httpsOptions = {\n    key: fs.readFileSync('proxy-mirror.key', 'utf8'),\n    cert: fs.readFileSync('proxy-mirror.crt', 'utf8')\n  };\n<p>var proxyServer = httpProxy.createServer(function (req, res, proxy) {\nconsole.log(‘will proxy request’, req.url);\nvar hostNameHeader = req.headers.host,\nhostAndPort = hostNameHeader.split(’:’),\nhost = hostAndPort[0],\nport = parseInt(hostAndPort[1]) || 80;\nproxy.proxyRequest(req, res, {\nhost: host,\nport: port\n});\n});</p>\n<p>proxyServer.addListener(‘connect’, function (request, socketRequest, bodyhead) {\nvar srvSocket = net.connect(8889, ‘localhost’, function () {\nsocketRequest.write(‘HTTP/1.1 200 Connection Established\\r\\n\\r\\n’);\nsrvSocket.write(bodyhead);\nsrvSocket.pipe(socketRequest);\nsocketRequest.pipe(srvSocket);\n});\n});</p>\n<p>var fakeHttps = https.createServer(httpsOptions, function (req, res) {\nvar hostNameHeader = req.headers.host,\nhostAndPort = hostNameHeader.split(’:’),\nhost = hostAndPort[0],\nport = parseInt(hostAndPort[1]) || 443;</p>\n<p>  proxyServer.proxy.proxyRequest(req, res, {\nhost: host,\nport: port,\nchangeOrigin: true,\ntarget: {\nhttps: true\n}\n});\n});</p>\n<p>proxyServer.listen(8888);\nfakeHttps.listen(8889);</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;h2&gt;HTML5 WebSocket support&lt;/h2&gt;\n&lt;p&gt;The above code has still problems handling &lt;a href=&quot;http://en.wikipedia.org/wiki/WebSocket&quot; target=&quot;_blank&quot;&gt;WebSockets&lt;/a&gt;. This is because browsers, according to the spec, change the way they establish initial connection when they detect that they are\n  behind an http proxy. As you can read on &lt;a href=&quot;http://en.wikipedia.org/wiki/WebSocket#Proxy_traversal&quot; target=&quot;_blank&quot;&gt;wikipedia&lt;/a&gt; more existing http proxy implementation suffer from this.&amp;#160; I still haven’t figured out how to handle this scenario\n  elegantly with http-proxy and node.js, when I do I will post my findings here.&lt;/p&gt;</code></pre></div>","fields":{"slug":"/an-https-system-proxy-with-node/","tagSlugs":["/tag/http/","/tag/node-js/","/tag/https/","/tag/proxy/"]},"excerpt":"openssl rsa -passin pass:x -in proxy-mirror.pass.key -out proxy-mirror.key\nrm proxy-mirror.pass.key\necho “Generated proxy-mirror.key” openssl req -new -batch -key proxy-mirror.key -out proxy-mirror.csr -subj /CN=proxy-mirror/emailAddress=piotr.mionskowski@gmail.com/OU=proxy-mirror/C=PL/O=proxy-mirror\necho “Generated…","frontmatter":{"date":"2014-01-03 06:34:00","description":null,"tags":["http","node.js","https","proxy"],"title":"An HTTPS system proxy with node","socialImage":null}}},"pageContext":{"slug":"/an-https-system-proxy-with-node/"}}}