{"componentChunkName":"component---src-templates-post-template-tsx","path":"/android-data-binding-part-1-why-it-is-important/","result":{"data":{"markdownRemark":{"id":"2c1e1ebe-4150-527b-9f09-7970a1f4c76e","html":"<p>Android application code often suffers from being more verbose than it could be. As libraries such as <a href=\"http://androidannotations.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Android Annotations</a> and <a href=\"http://jakewharton.github.io/butterknife/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ButterKnife</a> have shown that’s only partially due to tediousness of Java. The <a href=\"https://events.google.com/io2015/schedule?sid=128c9f91-b6d4-e411-b87f-00155d5066d7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">recently</a> announced <a href=\"https://developer.android.com/tools/data-binding/guide.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Android Data Binding</a> library can remove at least part of the boilerplate code we need to write. Since I’ve always liked <a href=\"http://martinfowler.com/eaaDev/PresentationModel.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Presentation Model pattern (MVVM)</a> this is very dear to my heart. However just getting rid of a tedious code is not the main reason I’m so happy to see the new API. Let’s recap on common issues developer faces on Android and then I’ll show how using mentioned patterns with new offering from Google can mitigate them.</p>\n<h2 id=\"problems-with-classic-approach\" style=\"position:relative;\"><a href=\"#problems-with-classic-approach\" aria-label=\"problems with classic approach permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Problems with classic approach</h2>\n<p>I’ll explain that step by step using a registration form screen example. We need couple of fields like first name, last name and an email address. To make the example a bit more interesting and to make UX better we’ll use <a href=\"http://mds.is/float-label-demo/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">floating label</a> pattern. One of the simplest approaches <strong>without data binding</strong> (for first name only) might look like this:</p>\n<script src=\"https://gist.github.com/miensol/52b98f0fcbe89db81441.js?file=RegisterActivityClassic.java\"></script>\n<h3 id=\"memory-leaks\" style=\"position:relative;\"><a href=\"#memory-leaks\" aria-label=\"memory leaks permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Memory leaks</h3>\n<p>A seasoned Android developer will immediately spot that we’ve a potentially leaked activity here. The culprit is of course the anonymous inner class implementing <code class=\"language-text\">RegisterApi</code> callback (<code class=\"language-text\">Action2</code>), which in turn uses <code class=\"language-text\">findViewById</code>. However it’s not the mentioned method that retains the activity - in Java every non-static inner class will have <em>implicit</em> reference to the enclosing class instance. While this problem is so common I still haven’t found a concise solution in the Android SDK. There are however community driven libraries i.e. <a href=\"http://square.github.io/otto/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Otto</a> and <a href=\"https://github.com/ReactiveX/RxJava\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RxJava</a> that can help tackle this problem.</p>\n<h3 id=\"to-much-code-in-activity\" style=\"position:relative;\"><a href=\"#to-much-code-in-activity\" aria-label=\"to much code in activity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>To much code in Activity</h3>\n<p>Many of us, me including, are guilt of stuffing too much into <code class=\"language-text\">Activity</code> classes. Writing test and maintaining them can become a nightmare over time. The verbosity of Java only makes the matter worse. One way to slim activities down is to use <a href=\"http://martinfowler.com/eaaDev/uiArchs.html#Model-view-presentermvp\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Presenter pattern</a> written either by hand or with the help of <a href=\"https://github.com/square/mortar\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Mortar</a>. Another solution is to encapsulate more logic into custom view classes used in layouts and using shared static helper methods with common code that calls Android API. Nevertheless, for a programmer that just starts with Android, it’s important that the framework provides guidance and samples that encourage separation of concerns - in my opinion up until now that was rarely the case.</p>\n<h3 id=\"maintaining-layout-files\" style=\"position:relative;\"><a href=\"#maintaining-layout-files\" aria-label=\"maintaining layout files permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Maintaining layout files</h3>\n<p>Many if not most screens in Android (and other platforms, too) are <em>read-only</em>. That is they are not forms and fields that user can change. Instead they offer neatly presented content with some way of interacting with it (as opposed to changing it directly). When using Android layout files we’re forced to use references (auto generated in <code class=\"language-text\">R</code> class by aapt) that allow setting view’s properties. This isn’t something necessarily bad especially if you need to heavily interact with a <code class=\"language-text\">View</code>. Having said that, how often you used <code class=\"language-text\">findViewById</code> (or <code class=\"language-text\">@InjectView</code>) just to set the content of <code class=\"language-text\">TextView</code> or had to refactor activity fields type because of a change in a layout definition?</p>\n<h2 id=\"android-data-binding-can-help-you\" style=\"position:relative;\"><a href=\"#android-data-binding-can-help-you\" aria-label=\"android data binding can help you permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Android Data Binding can help you.</h2>\n<p>The following code illustrates how registration form might look like <strong>with data binding</strong>:</p>\n<script src=\"https://gist.github.com/miensol/44ac5af33a60ad60cab7.js?file=RegisterActivity.java\"></script>\n<p>The new <code class=\"language-text\">RegisterActivity</code> is similar to previous example. We inflate the layout differently to initialize data binding and get an instance of <code class=\"language-text\">ActivityRegisterBinding</code> class. The class, with the name derived from layout name, is generated by data binding and its main purpose is to provide a glue between a view and an observable view model. When using <code class=\"language-text\">registerApi.register</code> we only reference <code class=\"language-text\">form</code> variable thus avoid unnecessarily referencing the activity. The <code class=\"language-text\">RegisterForm</code> class is a <em>view model</em> for our layout and has all the data that <code class=\"language-text\">activity_register</code> layout requires.</p>\n<script src=\"https://gist.github.com/miensol/44ac5af33a60ad60cab7.js?file=RegisterForm.java\"></script>\n<p>The view model has 3 observable attributes marked with <code class=\"language-text\">@Bindable</code> annotation. We don’t strictly need a backing field as the <code class=\"language-text\">getFirstNameLabelVisibility</code> shows. What we do need is to fire change notification events, which is done via <code class=\"language-text\">notifyPropertyChanged</code> and <code class=\"language-text\">notifyChange</code> methods available on <code class=\"language-text\">BaseObservable</code>. The former method accepts a field id that is assigned by data binding processor in generated class <code class=\"language-text\">BR</code> (similarily to <code class=\"language-text\">R</code> class). Deriving from <code class=\"language-text\">BaseObservable</code> is not a must - to make a model bindable it has to implement <code class=\"language-text\">android.databinding.Observable</code>.\nLast but not least a layout file:</p>\n<script src=\"https://gist.github.com/miensol/44ac5af33a60ad60cab7.js?file=activity_register.xml\"></script>\n<p>The data binding library, while still in beta, provides a nice toolset to remove the boilerplate code and improve Android code (unit) testability by extracting the logic from activity (or fragment). When used properly it can also save you from leaking resources. In the <a href=\"/android-data-binding-part-2-observer-pattern-to-the-bone\">next post</a> I’ll explain in more detail how it happens.</p>\n<p><em>This article is cross-posted with <a href=\"http://blog.brightinventions.pl\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">my company blog</a></em></p>","fields":{"slug":"/android-data-binding-part-1-why-it-is-important/","tagSlugs":["/tag/android/"]},"excerpt":"Android application code often suffers from being more verbose than it could be. As libraries such as Android Annotations and ButterKnife have shown that’s only partially due to tediousness of Java. The recently announced Android Data Binding library can remove at least part of the boilerplate code we need to write…","frontmatter":{"date":"2015-07-20 08:36","description":null,"tags":["android"],"title":"Android Data Binding Part 1: Why it is important","socialImage":null}}},"pageContext":{"slug":"/android-data-binding-part-1-why-it-is-important/"}}}