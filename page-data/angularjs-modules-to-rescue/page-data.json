{"componentChunkName":"component---src-templates-post-template-tsx","path":"/angularjs-modules-to-rescue/","result":{"data":{"markdownRemark":{"id":"9080f7f1-e449-5d1d-bd80-69bdef2e8c1e","html":"<div class=\"css-full-post-content js-full-post-content\">\n  Building large scale JavaScript application is a tough problem. The language nature is malleable and it does not have proper modules mechanism built in. Some argue that <a href=\"http://lostechies.com/derickbailey/2012/06/04/anders-hejlsberg-is-right-you-cannot-maintain-large-programs-in-javascript/\"\n  target=\"_blank\">you can’t really built and maintain</a> big applications built with JavaScript.&nbsp; Others say that the key in succeeding is to <a href=\"http://addyosmani.com/largescalejavascript/\" target=\"_blank\">never built big applications</a> but\n  to approach things in a more clever way – by applying <a href=\"http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm\" target=\"_blank\">divide and conquer</a> rule.\n  <h2>Dividing code base</h2>Due to lack of modules mechanism in <a href=\"http://en.wikipedia.org/wiki/ECMAScript\" target=\"_blank\">ECMAScript</a> 5th edition, which is the version most commonly available in browsers, there were couple of implementations created. <a href=\"http://requirejs.org/\"\n  target=\"_blank\">RequireJs</a> and <a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\" target=\"_blank\">AMD</a> are just 2 most popular ones. Angular team decided to provide it’s own implementation of modules and left the asynchronous loading of them to\n  existing tools. I suspect that it was because they didn’t want to create a dependency on 3rd party library and because of their use of dependency injection. The framework relies on modules heavily making it possible to use just the parts that you actually\n  need saving precious network and loading time. Here is how to define a module:\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var myApp = angular.module(&#39;myApp&#39;, [&#39;ngResource&#39;]);\n\nmyApp.factory(&#39;itemsStorage&#39;, function ($resource) {\n  var itemsStorage = ...;\n  // items storage implementation\n  return itemsStorage;\n});</code></pre></div>\n<p>We’ve\ndeclared a new module called <em>myApp </em>and stated that it depends on another module called <em>ngResource</em>. In line 3 we are declaring a factory for <em>itemsStorage</em> that requires <em><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>c</mi><mi>e</mi><mo>&lt;</mo><mi mathvariant=\"normal\">/</mi><mi>e</mi><mi>m</mi><mo>&gt;</mo><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi mathvariant=\"normal\">.</mi><mi>A</mi><mi>n</mi><mi>g</mi><mi>u</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>l</mi><mi>l</mi><mi>a</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>y</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>v</mi><mi>e</mi><mo>&lt;</mo><mi>e</mi><mi>m</mi><mo>&gt;</mo></mrow><annotation encoding=\"application/x-tex\">resource&lt;/em&gt; service. Angular will automatically resolve &lt;em&gt;</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">/</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">e</span><span class=\"mord\">.</span><span class=\"mord mathdefault\">A</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">m</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">c</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">s</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathdefault\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">m</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span></span></span>resource</em> service\nand inject it as a value of parameter. As you may suspect under the hood the dependency injection mechanism inspects parameter names of our function and thus it is able to know how to satisfy them with proper values. Be careful when using JavaScript\nminimizing tools because most of them will by default shorten parameter names and that will break the DI. The only work around for it is to disable an option responsible for parameters in minimizer. Most of the times I find it useful to split one module\ndefinition across couple of files. It is a supported scenario but there are some quirks to it.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var myApp = angular.module(&#39;myApp&#39;);\n\nmyApp.directive(&#39;timeAgo&#39;, function(){\n  return function($scope, $element, $attrs){\n    // timeAgo directive link implmentation\n  };\n});</code></pre></div>\n<p>The\nfirst line says that we would like to retrieve <em>myApp</em> module so that we can extend or use it. This API may be confusing, it was for me, as it may look like we’re actually declaring a module that has no dependencies. The distinction between extending\nand declaring a module has an important ramification. You’re now responsible of loading file with module declaration before files that extend module functionality. In order to declare module with no dependencies you have to pass an empty array as a\nsecond argument:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var secondModule = angular.module(&#39;secondModule&#39;, []);</code></pre></div>\n  <h2>A praise of dependency injection</h2>\n  <p>Dependency injection is a very useful concept especially in statically typed languages as C# or Java. It really helps you decouple your code as your classes no longer require to know about the implementation details of their dependencies. There are\n    several ways to implement this pattern however must commonly used is a constructor injection. A lot of IoC containers exists both in .NET and Java world: Castle.Windsor, StructureMap, Guice or Ninject are just a few. However I have never seen a viable\n    implementation of DI in JavaScript until AngularJs.</p>\n  <p>At first it seemed like a magic, so much that I actually had to dig into the framework code base to see how it’s done. As it turned out the idea behind the implementation is really simple. I did however encounter problems while trying to figure out\n    why a particular service cannot be resolved or a directive isn’t working. Usually it was because of typos in parameter names or a missing dependency in module declaration. I know that the Angular team has put effort to make it easier to figure out\n    those kind of problems in a recent release.</p>\n  <p>I’ve heard opinions that in a dynamic language as JavaScript the DI provides little to know gain instead adding an accidental complexity. I do agree that it is possible to live without however it requires much more discipline to keep a code clean. Whenever\n    you create a service (a piece of code) that will be used in several places you have to make sure not to leak implementation details to clients (the ones that use the service). Without DI it means you have to make it easy to create a service by hand,\n    typically by providing a factory method or a parameter less constructor. If you won’t take care of it upfront it will be harder to refactor the service implementation later on because of the number of clients that create it. When using DI at least\n    this one task is forced upon you upfront.</p>\n  <p>Now what makes an actual implementation of DI practical is its ease of use. If you remember a time when most of C# and Java IoC containers required declaring actual object graph in an XML files you’ll understand what I mean. I think Angular team made\n    using dependency injection feel easy and very natural and that’s what makes it so useful.</p>\n  <h2>Dependency resolution and conflicts</h2>There is an important limitation in Angular modules implementation around conflict resolution. Basically the framework uses last wins approach so you really have to be careful while naming things. It may seem not important at first but let’s consider\n  following code sample.\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var A = angular.module(&#39;A&#39;, []);\n\nA.factory(&#39;serviceA&#39;, function(){\n return function(){\n  console.log(&#39;using serviceA defined in module A&#39;);\n };\n});\n\nvar B = angular.module(&#39;B&#39;, [&#39;A&#39;]);\n\nB.factory(&#39;serviceB&#39;, function(serviceA){\n return function(){\n  console.group(&#39;using serviceB defined in module A&#39;);\n  serviceA();\n  console.groupEnd();\n };\n});\n\nvar C = angular.module(&#39;C&#39;, [&#39;A&#39;]);\n\nC.factory(&#39;serviceA&#39;, function(){\n return function(){\n  console.log(&#39;using serviceA defined in module C&#39;);\n };\n});\n\nC.factory(&#39;serviceC&#39;, function(serviceA){\n return function(){\n  console.group(&#39;using serviceC defined in module C&#39;);\n  serviceA();\n  console.groupEnd();\n };\n});</code></pre></div>\n<p>As you can see we have 3 modules here <em>A, B </em>and<em> C</em>. But in line <em>21</em> inside <em>C</em> module definition we&#x2019;re declaring <em>serviceA</em>. Since module <em>C</em> depends on <em>A</em> that already defined <em>serviceA</em> we&#x2019;re actually\n    overriding the implementation. It&#x2019;s quite useful to be able to override and stuff our custom implementation of particular service provided by other module. Except that we have no control over the scope of our modification. In the above example the <em>serviceA</em> defined\n    in module <em>C</em> will be the one used everywhere at runtime. Even though module <em>B</em> knows nothing bout <em>C.</em> Calling declared services like this:\n```\nserviceA();\nserviceB();\nserviceC();\n```\nWill\n    produce following output:\n    </p><div>\n      <a href=\"http://lh3.ggpht.com/-1Kk4GFZY1Ac/UjdAULJnNPI/AAAAAAAAA-0/Ysrp9fPRtO4/s1600-h/image%25255B13%25255D.png\">\n        <img alt=\"image\" border=\"0\" height=\"140\" src=\"http://lh4.ggpht.com/-jfB6FQ9O_RI/UjdAUlHuWHI/AAAAAAAAA-8/w1-wyY2sB70/image_thumb%25255B5%25255D.png?imgmax=800\" style=\"background-image: none; border-bottom: 0px; border-left: 0px; border-right: 0px; border-top: 0px; display: inline; padding-left: 0px; padding-right: 0px; padding-top: 0px;\" title=\"image\" width=\"379\">\n      </a>\n    </div>You can play around with this <a href=\"http://jsfiddle.net/miensol/z5TVc/\" target=\"_blank\">sample on jsfiddle</a>.<p></p>\n  <p>What can we do about it? The only advice I&#x2019;ve seen is to use prefix on <em>service</em> names. Now this is a working and simple approach however the code will not look great. I wonder how hard it would be to modify angular injector part to gain the ability\n    to gain more control over overriding things&#x2026;</p>\n","fields":{"slug":"/angularjs-modules-to-rescue/","tagSlugs":["/tag/javascript/","/tag/angularjs/"]},"excerpt":"We’ve\n  declared a new module called myApp and stated that it depends on another module called ngResource. In line 3 we are declaring a factory for itemsStorage that requires resource service\n  and inject it as a value of parameter. As you may suspect under the hood the dependency injection mechanism inspects parameter…","frontmatter":{"date":"2013-09-16 17:44:00","description":null,"tags":["javascript","angularjs"],"title":"AngularJs modules to the rescue","socialImage":null}}},"pageContext":{"slug":"/angularjs-modules-to-rescue/"}}}